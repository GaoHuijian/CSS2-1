<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01//EN">
<html lang="zh-CN">
<head>
<meta http-equiv="Content-Type" content="text/html;charset=utf-8">
<meta name="viewport" content="width=device-width,minimum-scale=1.0,maximum-scale=1.0,user-scalable=no"/>
<title>内容生成，自动编号与列表</title>
<link rel="stylesheet" href="style/default.css" type="text/css">
<link rel="stylesheet" href="style/W3C-REC.css" type="text/css">
<link rel="prev" href="visufx.html">
<link rel="next" href="page.html">
<link rel="contents" href="cover.html#minitoc">
<link rel="CSS-properties" href="propidx.html" title="properties">
<link rel="index" href="indexlist.html" title="index">
<link rel="first" href="cover.html">

</head>
<body>
<div class="navbar">
<p><a href="visufx.html">上一章</a> &nbsp;
<a href="page.html">下一章</a> &nbsp;
<a href="cover.html#minitoc">内容</a> &nbsp;
<a href="propidx.html">属性</a> &nbsp;
<a href="indexlist.html">索引</a> &nbsp;
</div>
<hr class="navbar">

<h1>12 
<a name="x0"><span class="index-def" title="generated content">内容</span></a><a name="generated-text">生成</a>，自动<a name="x1"><span class="index-def" title="automatic numbering">编号</span></a>和列表</h1>
<div class="subtoc">
<p><strong>内容</strong>
  <ul class="toc">
    <li class="tocline2"><a href="generate.html#before-after-content" class="tocxref">12.1 <span class="index-def" title=":before|pseudo-elements:::before|before">:before</span>与<span class="index-def" title=":after|pseudo-elements:::after|after">:after</span>伪元素</a>
    <li class="tocline2"><a href="generate.html#content" class="tocxref">12.2 <span class="propinst-content">'content'</span>属性</a>
    <li class="tocline2"><a href="generate.html#quotes" class="tocxref">12.3 引号</a>
    <ul class="toc">
      <li class="tocline3"><a href="generate.html#quotes-specify" class="tocxref">12.3.1 用<span class="propinst-quotes">'quotes'</span>属性指定引号</a>
      <li class="tocline3"><a href="generate.html#quotes-insert" class="tocxref">12.3.2 用<span class="propinst-content">'content'</span>属性插入引号</a>
    </ul>
    <li class="tocline2"><a href="generate.html#counters" class="tocxref">12.4 自动<span class="index-def" title="counters">计数器</span>与编号</a>
    <ul class="toc">
      <li class="tocline3"><a href="generate.html#scope" class="tocxref">12.4.1 嵌套计数器与范围</a>
      <li class="tocline3"><a href="generate.html#counter-styles" class="tocxref">12.4.2 计数器样式</a>
      <li class="tocline3"><a href="generate.html#undisplayed-counters" class="tocxref">12.4.3 'display: none'的元素中的计数器</a>
    </ul>
    <li class="tocline2"><a href="generate.html#lists" class="tocxref">12.5 列表</a>
    <ul class="toc">
      <li class="tocline3"><a href="generate.html#list-style" class="tocxref">12.5.1 列表：<span class="propinst-list-style-type">'list-style-type'</span>，<span class="propinst-list-style-image">'list-style-image'</span>，<span class="propinst-list-style-position">'list-style-position'</span>和<span class="propinst-list-style">'list-style'</span>属性</a>
    </ul>
  </ul>
</div>

<p>某些情况下，编写者可能想让用户代理渲染来自<a href="conform.html#doctree">文档树</a>外的内容。一个熟悉的此类例子是编号列表，编写者不想显式地列出编号，他/她想让用户代理自动生成它们。类似的，编写者可能想让用户代理在一幅图的标题前插入“图”这个字，或者在第七章的标题前插入“第7章”。特殊地，对于音频或者盲文，用户代理应该也能插入这些字符串

<p>CSS 2.1中，内容可以通过两种机制生成：</p>

<ul>
<li><a href="generate.html#propdef-content" class="noxref"><span class="propinst-content">'content'</span></a>属性，结合:before和:after伪元素
<li>具有值为'list-item'的<a href="visuren.html#propdef-display" class="noxref"><span class="propinst-display">'display'</span></a>属性的元素
</ul>


<h2>12.1 <a name="before-after-content"> </a><a name="x2"><span class="index-def" title=":before|pseudo-elements:::before|before">:before</span></a>与<a name="x5"><span class="index-def" title=":after|pseudo-elements:::after|after">:after</span></a>伪元素</h2>

<p>编写者可以指定用:before和:after伪元素生成内容的样式和位置。如同它们的名字一样，:before和:after伪元素指定了位于一个元素的<a href="conform.html#doctree">文档树</a>内容之前和之后的内容的位置。<a href="generate.html#propdef-content" class="noxref"><span class="propinst-content">'content'</span></a>属性，结合这些伪元素，指定了插入什么（内容）

<div class=example><P style="display:none">示例：</P>
<p>例如，如下规则在每个"class"属性值含有"note"的P元素的内容之前插入了字符串"Note: "：</p>

<pre>
p.note:before { content: "Note: " }
</pre>
</div>

<P>由一个元素生成的格式化对象（例如，盒）包括生成的内容。所以，例如，把上面的样式表改为：</p>

<pre class="example">
p.note:before { content: "Note: " }
p.note        { border: solid green }
</pre>

<P>会让一条实线绿色边框环绕整段，包括初始字符串

<P>:before和:after伪元素会从文档树中它们附着的元素上<a href="cascade.html#inheritance">继承</a>所有可继承的属性</p>



<div class=example><P style="display:none">示例：</P>

<p>例如，如下规则在每个Q元素前插入了一个左引号(')。引号的颜色将是红色的，但字体将与Q元素其余部分的字体相同：</p>

<pre>
q:before {
  content: open-quote;
  color: red
}
</pre>
</div>

<p>在一个:before或者:after伪元素声明中，不可继承的属性取其<a href="about.html#initial-value">初始值</a></p>

<div class=example><P style="display:none">示例：</P>
<p>所以，例如，因为<a href="visuren.html#propdef-display" class="noxref"><span class="propinst-display">'display'</span></a>属性的初始值为'inline'，前一个示例中的引号会被当作一个行内框插入（即，与该元素的初始文本内容在同一行）。下一个示例显式地把<a href="visuren.html#propdef-display" class="noxref"><span class="propinst-display">'display'</span></a>属性设置为'block'了，以致于插入的文本变成了一个块：</p>

<pre>
body:after {
    content: "The End";
    display: block;
    margin-top: 2em;
    text-align: center;
}
</pre>

</div>

<p>:before和:after伪元素会与其它盒相互影响，就像它们是插在其相关元素里的真实元素一样</p>

<div class="example"><P style="display:none">示例：</P>
<p>例如，如下文档片段和样式表：</p>
<pre>
&lt;p> Text &lt;/p>                   p:before { display: block; content: 'Some'; }
</pre>
<p>...将与下列文档片段和样式表的渲染（方式）完全相同：</p>
<pre>
&lt;p>&lt;span>Some&lt;/span> Text &lt;/p>  span { display: block }
</pre>
<p>类似的，如下文档片段和样式表：</p>
<pre>
&lt;h2> Header &lt;/h2>     h2:after { display: block; content: 'Thing'; }
</pre>
<p>...将与下列文档片段和样式表的渲染方式完全相同：</p>
<pre>
&lt;h2> Header &lt;span>Thing&lt;/span>&lt;/h2>   h2 { display: block; }
                                      span { display: block; }
</pre>
</div>

<div class="note">
<p><strong>注意</strong> 本规范并没有完整定义:before和:after伪元素对可替换元素（例如HTML中的IMG）的相互影响。这会在将来的规范中详细定义</p>
</div>

<h2>12.2 <a name="content"> </a><a href="generate.html#propdef-content" class="noxref"><span
class="propinst-content">'content'</span></a>属性</h2>

<div class="propdef">
<dl><dt>
<span class="index-def" title="'content'"><a name="propdef-content" class="propdef-title"><strong>'content'</strong></a></span>
<dd>
<table class="propinfo" cellspacing=0 cellpadding=0>
<tr valign=baseline><td><em>Value:</em>&nbsp;&nbsp;<td>normal | none | [ <a href="syndata.html#value-def-string" class="noxref"><span class="value-inst-string">&lt;string&gt;</span></a> | <a href="syndata.html#value-def-uri" class="noxref"><span class="value-inst-uri">&lt;uri&gt;</span></a> | <a href="syndata.html#value-def-counter" class="noxref"><span class="value-inst-counter">&lt;counter&gt;</span></a> | attr(<a href="syndata.html#value-def-identifier" class="noxref"><span class="value-inst-identifier">&lt;identifier&gt;</span></a>) | open-quote | close-quote | no-open-quote | no-close-quote ]+ | <a href="cascade.html#value-def-inherit" class="noxref"><span class="value-inst-inherit">inherit</span></a>
<tr valign=baseline><td><em>Initial:</em>&nbsp;&nbsp;<td>normal
<tr valign=baseline><td><em>Applies to:</em>&nbsp;&nbsp;<td>:before和:after伪元素
<tr valign=baseline><td><em>Inherited:</em>&nbsp;&nbsp;<td>no
<tr valign=baseline><td><em>Percentages:</em>&nbsp;&nbsp;<td>N/A
<tr valign=baseline><td><em>Media:</em>&nbsp;&nbsp;<td><a href="media.html#all-media-group" class="noxref">all</a>
<tr valign=baseline><td><em>Computed&nbsp;value:</em>&nbsp;&nbsp;<td>对于元素，计算值为'normal'。对于:before和:after，如果指定值为'normal'，计算值就是'none'。否则，对于URI值，（计算值）就是绝对URI；对于attr()值，就是产生的字符串；对于其它关键字，就与指定值相同
</table>
</dl>
</div>


<p>该属性配合:before和:after伪元素来在文档中生成内容。值含义如下：</p>

<dl>

<dt><a name="x9"><span class="index-inst" title="none"><strong>none</strong></span></a>
<dd>不生成该伪元素</dd>

<dt><a name="x10"><span class="index-inst" title="normal"><strong>normal</strong></span></a>
<dd>对于:before和:after伪元素计算值为'none'</dd>

<dt><span class="index-inst" title="&lt;string&gt;"><a name="x11" href="syndata.html#value-def-string" class="noxref"><span class="value-inst-string"><strong>&lt;string&gt;</strong></span></a></span>
<dd>文本内容（见<a href="syndata.html#strings">字符串</a>小节）

<dt><span class="index-inst" title="&lt;uri&gt;"><a name="x12" href="syndata.html#value-def-uri" class="noxref"><span class="value-inst-uri"><strong>&lt;uri&gt;</strong></span></a></span>
<dd>该值是一个URI，指定了一个外部资源（例如一张图片）。如果用户代理无法显示该资源，它必须忽略它就像没有指定它一样，或者显示一些该资源无法显示的提示

<dt><span class="index-inst" title="&lt;counter&gt;"><a name="x13" href="syndata.html#value-def-counter" class="noxref"><span
class="value-inst-counter"><strong>&lt;counter&gt;</strong></span></a></span>
<dd><a href="syndata.html#counter">计数器</a>可以通过两个函数来指定：'counter()'或者'counters()'。前者有两种形式：'counter(<var>name</var>)'或者'counter(<var>name</var>, <var>style</var>)'。生成的文本是该伪元素所在范围中名为给定name的最内层计数器的值，被格式化为指定的<a href="#counter-styles">style</a>（默认是'decimal'）。后者也有两种形式：'counters(<var>name</var>, <var>string</var>)'或者'counters(<var>name</var>, <var>string</var>, <var>style</var>)'。生成的文本是该伪元素所在范围中的所有名为给定name的计数器的值，从指定string分隔的最外层到最内层。计数器被渲染为指定的<a href="#counter-styles">style</a>（默认是'decimal'）。更多信息见<a href="#counters">自动计数器与编号</a>。name必须不为'none'，'inherit'或者'initial'，这样的name会导致声明被忽略掉

<dt><span class="index-inst" title="open-quote"><a name="x14" href="generate.html#value-def-open-quote" class="noxref"><span class="value-inst-open-quote"><strong>open-quote</strong></span></a></span>和<span class="index-inst" title="close-quote"><a name="x15" href="generate.html#value-def-close-quote" class="noxref"><span class="value-inst-close-quote"><strong>close-quote</strong></span></a></span>

<dd>这些值会根据<a href="generate.html#propdef-quotes" class="noxref"><span class="propinst-quotes"><strong>'quotes'</strong></span></a>属性替换为合适的字符串

<dt><span class="index-inst" title="no-open-quote"><a name="x16" href="generate.html#value-def-no-open-quote" class="noxref"><span class="value-inst-no-open-quote"><strong>no-open-quote</strong></span></a></span>与<span class="index-inst" title="no-close-quote"><a name="x17" href="generate.html#value-def-no-close-quote" class="noxref"><span class="value-inst-no-close-quote"><strong>no-close-quote</strong></span></a></span>

<dd>不引入内容，但会增加（减少）引号的嵌套层级

<dt><a name="x18"><span class="index-def" title="attr()"><strong>attr(X)</strong></span></a>
<dd>该函数返回一个字符串，为该选择器的对象（subject）的X属性的值。该字符串不会被CSS处理器解析。如果该选择器的对象没有X属性，就返回一个空字符串。属性名的大小写敏感性取决于文档语言
</dl>

<div class="note">
<strong>注意</strong> CSS 2.1中。不可能引用除该选择器的对象外的其它元素的属性值
</div>


<P><a href="visuren.html#propdef-display" class="noxref"><span class="propinst-display">'display'</span></a>属性控制内容放在一个块还是行内框里

<div class="example"><P style="display:none">示例：</P><p>如下规则会在每个H1元素前生成字符串"Chapter: "：</p>

<pre>
H1:before { 
  content: "Chapter: ";
  display: inline;
}
</pre>
</div>

<p>编写者可以通过在<a href="generate.html#propdef-content" class="noxref"><span class="propinst-content">'content'</span></a>属性后面的字符串中写上"\A"转义序列，来在生成的内容中包含换行（newlines）。插入的这个行结束符也受<a href="text.html#propdef-white-space" class="noxref"><span class="propinst-white-space">'white-space'</span></a>属性约束。关于"\A"转义序列的更多信息见<a href="syndata.html#strings">“字符串”</a>和<a href="syndata.html#escaped-characters">“字符和大小写”</a>

<div class="example"><P style="display:none">示例：</P><P>

<PRE>
h1:before {
    display: block;
    text-align: center;
    white-space: pre;
    content: "chapter\A hoofdstuk\A chapitre"
}
</pre>
</div>

<P>生成的内容不会改变文档树。特别的，它不会反馈给文档语言处理器（例如，用于重新解析）

<h2>12.3 <a name="quotes">引号</a></h2>

<P>CSS 2.1中，编写者可以指定用户代理应该怎样渲染引号，以风格敏感的（style-sensitive）还是依赖上下文的（context-dependent）方式。<a href="generate.html#propdef-quotes" class="noxref"><span class="propinst-quotes">'quotes'</span></a>属性为每层内嵌引用指定了引号对。<a href="generate.html#propdef-content" class="noxref"><span class="propinst-content">'content'</span></a>属性允许访问那些引号，并且会让他们插入在一个引用（quotation）之前和之后

<H3>12.3.1 <a name="quotes-specify"> </a>用<a href="generate.html#propdef-quotes" class="noxref"><span class="propinst-quotes">'quotes'</span></a>属性指定引号</H3>

<div class="propdef">
<dl><dt>
<span class="index-def" title="'quotes'"><a name="propdef-quotes" class="propdef-title"><strong>'quotes'</strong></a></span>
<dd>
<table class="propinfo" cellspacing=0 cellpadding=0>
<tr valign=baseline><td><em>Value:</em>&nbsp;&nbsp;<td>[<a href="syndata.html#value-def-string" class="noxref"><span class="value-inst-string">&lt;string&gt;</span></a> <a href="syndata.html#value-def-string" class="noxref"><span class="value-inst-string">&lt;string&gt;</span></a>]+ | none | <a href="cascade.html#value-def-inherit" class="noxref"><span class="value-inst-inherit">inherit</span></a>
<tr valign=baseline><td><em>Initial:</em>&nbsp;&nbsp;<td>取决于用户代理
<tr valign=baseline><td><em>Applies to:</em>&nbsp;&nbsp;<td>所有元素
<tr valign=baseline><td><em>Inherited:</em>&nbsp;&nbsp;<td>yes
<tr valign=baseline><td><em>Percentages:</em>&nbsp;&nbsp;<td>N/A
<tr valign=baseline><td><em>Media:</em>&nbsp;&nbsp;<td><a href="media.html#visual-media-group" class="noxref">visual</a>
<tr valign=baseline><td><em>Computed&nbsp;value:</em>&nbsp;&nbsp;<td>与指定值相同
</table>
</dl>
</div>


<P>该属性为所有内嵌引用指定了引号。值含义如下：</p>

<dl>
<dt><strong>none</strong>

<dd>值为'open-quote'和'close-quote'的<a href="generate.html#propdef-content" class="noxref"><span class="propinst-content">'content'</span></a>属性不会产生引号

<dt>[<span class="index-inst" title="&lt;string&gt;"><a name="x20" href="syndata.html#value-def-string" class="noxref"><span class="value-inst-string"><strong>&lt;string&gt;</strong></span></a></span>&nbsp;<span class="index-inst" title="&lt;string&gt;"><a name="x21" href="syndata.html#value-def-string" class="noxref"><span class="value-inst-string"><strong>&lt;string&gt;</strong></span></a></span>]+

<dd>值为'open-quote'和'close-quote'的<a href="generate.html#propdef-content" class="noxref"><span class="propinst-content">'content'</span></a>属性从（属性值）列出的引号（左引号和右引号）对中取。第一（最左边的）对代表最外层引用，第二对是第一层内嵌，等等。用户代理必须根据内嵌层级来应用合适的引号对
</dl>


<div class="example"><P style="display:none">示例：</P>
<P>例如，应用下列样式表：</p>

<PRE class="example">
/* Specify pairs of quotes for two levels in two languages */
q:lang(en) { quotes: '"' '"' "'" "'" }
q:lang(no) { quotes: "«" "»" '"' '"' }

/* Insert quotes before and after Q element content */
q:before { content: open-quote }
q:after  { content: close-quote }
</PRE>

<P>到如下HTML片段：</p>

<PRE class="html-example">
&lt;HTML lang="en"&gt;
  &lt;HEAD&gt;
  &lt;TITLE&gt;Quotes&lt;/TITLE&gt;
  &lt;/HEAD&gt;
  &lt;BODY&gt;
    &lt;P&gt;&lt;Q&gt;Quote me!&lt;/Q&gt;
  &lt;/BODY&gt;
&lt;/HTML&gt;
</PRE>

<P>将会让一个用户代理产生：</p>

<PRE class="ascii-art">
"Quote me!"
</PRE>

<P>如果是这个HTML片段：</p>

<PRE class="html-example">
&lt;HTML lang="no"&gt;
  &lt;HEAD&gt;
  &lt;TITLE&gt;Quotes&lt;/TITLE&gt;
  &lt;/HEAD&gt;
  &lt;BODY&gt;
    &lt;P&gt;&lt;Q&gt;Tr&oslash;ndere gr&aring;ter n&aring;r &lt;Q&gt;Vinsjan p&aring; kaia&lt;/Q&gt; blir deklamert.&lt;/Q&gt;
  &lt;/BODY&gt;
&lt;/HTML&gt;
</PRE>

<P>将会产生：</p>

<PRE class="ascii-art">
«Tr&oslash;ndere gr&aring;ter n&aring;r "Vinsjan p&aring; kaia" blir deklamert.»
</PRE>
</div>

<div class="note"><P>
<em><strong>注意</strong>
尽管前一个示例中通过<a href="generate.html#propdef-quotes" class="noxref"><span
class="propinst-quotes">'quotes'</span></a>指定的引号都很方便地出现在计算机键盘上，高质量排版将会需要不同的ISO 10646字符。下面信息性的表格列出了一些ISO 10646引号字符：</em></p>

<TABLE border>
<TR><TH>Character</TH><TH>Approximate rendering<TH>ISO 10646 code (hex)<TH>Description
<TR><TD>&#x0022;<TD>"<TD>0022<TD>QUOTATION MARK [the ASCII double quotation mark]
<TR><TD>&#x0027;<TD>'<TD>0027<TD>APOSTROPHE     [the ASCII single quotation mark]
<TR><TD>&#x2039;<TD>&lt;<TD>2039<TD>SINGLE LEFT-POINTING ANGLE QUOTATION MARK
<TR><TD>&#x203A;<TD>><TD>203A<TD>SINGLE RIGHT-POINTING ANGLE QUOTATION MARK
<TR><TD>&#x00AB;<TD>«<TD>00AB<TD>LEFT-POINTING DOUBLE ANGLE QUOTATION MARK
<TR><TD>&#x00BB;<TD>»<TD>00BB<TD>RIGHT-POINTING DOUBLE ANGLE QUOTATION MARK
<TR><TD>&#x2018;<TD>`<TD>2018<TD>LEFT SINGLE QUOTATION MARK [single high-6]
<TR><TD>&#x2019;<TD>'<TD>2019<TD>RIGHT SINGLE QUOTATION MARK [single high-9]
<TR><TD>&#x201C;<TD>``<TD>201C<TD>LEFT DOUBLE QUOTATION MARK  [double high-6]
<TR><TD>&#x201D;<TD>''<TD>201D<TD>RIGHT DOUBLE QUOTATION MARK [double high-9]
<TR><TD>&#x201E;<TD>,,<TD>201E<TD>DOUBLE LOW-9 QUOTATION MARK [double low-9]
</TABLE>
</div>


<H3>12.3.2 <a name="quotes-insert"> </a>用<a href="generate.html#propdef-content" class="noxref"><span class="propinst-content">'content'</span></a>属性插入引号</H3>

<p>可以用值为<span class="index-def" title="open-quote"><a class="value-def" name="value-def-open-quote">'open-quote'</a></span>和<span class="index-def" title="close-quote"><a class="value-def" name="value-def-close-quote">'close-quote'</a></span>的<a href="generate.html#propdef-content" class="noxref"><span class="propinst-content">'content'</span></a>属性在文档中合适的地方插入引号。出现的每个'open-quote'或者'close-quote'会被替换为<a href="generate.html#propdef-quotes" class="noxref"><span class="propinst-quotes">'quotes'</span></a>值中的某个字符串，根据嵌套的深度来定

<p>'Open-quote'表示一对引号中的第一个，'close-quote'表示第二个。使用哪一对引号取决于引用的嵌套层级：'open-quote'在当前位置之前的所有生成文本中的出现次数，减去'close-quote'的出现次数。如果深度为0，就用第一对，如果深度为1，就用第2对，等等。如果深度大于（引号）对数，就重复最后一对。一个会让深度变为负数的'close-quote'或者'no-close-quote'属于错误情况，会被忽略掉（在渲染时）：深度为0且不渲染引号（尽管仍然会插入'content'属性值的其余部分）


<div class="note"><p>
<em><strong>注意</strong> 引用深度独立于源文档或者格式化结构的嵌套</em>
</p></div>

<p>一些排版样式需要让左引号在横跨多段的引用中的每个段落前重复，但只在最后一段的结尾处有一个右引号。CSS中，这可以通过插入“虚拟（phantom）”右引号来实现。关键字<span class="index-def" title="no-close-quote"><a class="value-def" name="value-def-no-close-quote">'no-close-quote'</a></span>能减少引用层级，但不会插入一个引号


<div class="example"><P style="display:none">示例：</P>
<p>下列样式表会给BLOCKQUOTE中的每个段落添上一个左引号，并在末尾插入一个右引号：

<pre>
blockquote p:before     { content: open-quote }
blockquote p:after      { content: no-close-quote }
blockquote p.last:after { content: close-quote }
</pre>

<P>这需要给最后一段标记一个"last"类
</div>

<p>对称的，也有一个<span class="index-def" title="no-open-quote"><a class="value-def" name="value-def-no-open-quote">'no-open-quote'</a></span>关键字，不插入任何东西，但会让引用深度加1


<h2>12.4 自动<span class="index-def" title="counters"><a name="counters">计数器</a></span>与编号</h2>

<p>自动编号在CSS&nbsp;2.1中是通过两个属性控制的，<a href="generate.html#propdef-counter-increment" class="noxref"><span class="propinst-counter-increment">'counter-increment'</span></a>和<a href="generate.html#propdef-counter-reset" class="noxref"><span class="propinst-counter-reset">'counter-reset'</span></a>。通过这些属性定义的计数器用于<a href="generate.html#propdef-content" class="noxref"><span class="propinst-content">'content'</span></a>属性的counter()和counters()属性

<div class="propdef">
<dl><dt>
<span class="index-def" title="'counter-reset'"><a name="propdef-counter-reset" class="propdef-title"><strong>'counter-reset'</strong></a></span>
<dd>
<table class="propinfo" cellspacing=0 cellpadding=0>
<tr valign=baseline><td><em>Value:</em>&nbsp;&nbsp;<td>[ <a href="syndata.html#value-def-identifier" class="noxref"><span class="value-inst-identifier">&lt;identifier&gt;</span></a> <a href="syndata.html#value-def-integer" class="noxref"><span class="value-inst-integer">&lt;integer&gt;</span></a>? ]+ | none | <a href="cascade.html#value-def-inherit" class="noxref"><span class="value-inst-inherit">inherit</span></a>
<tr valign=baseline><td><em>Initial:</em>&nbsp;&nbsp;<td>none
<tr valign=baseline><td><em>Applies to:</em>&nbsp;&nbsp;<td>所有元素
<tr valign=baseline><td><em>Inherited:</em>&nbsp;&nbsp;<td>no
<tr valign=baseline><td><em>Percentages:</em>&nbsp;&nbsp;<td>N/A
<tr valign=baseline><td><em>Media:</em>&nbsp;&nbsp;<td><a href="media.html#all-media-group" class="noxref">all</a>
<tr valign=baseline><td><em>Computed&nbsp;value:</em>&nbsp;&nbsp;<td>与指定值相同
</table>
</dl>
</div>

<div class="propdef">
<dl><dt>
<span class="index-def" title="'counter-increment'"><a name="propdef-counter-increment" class="propdef-title"><strong>'counter-increment'</strong></a></span>
<dd>
<table class="propinfo" cellspacing=0 cellpadding=0>
<tr valign=baseline><td><em>Value:</em>&nbsp;&nbsp;<td>[ <a href="syndata.html#value-def-identifier" class="noxref"><span class="value-inst-identifier">&lt;identifier&gt;</span></a> <a href="syndata.html#value-def-integer" class="noxref"><span class="value-inst-integer">&lt;integer&gt;</span></a>? ]+ | none | <a href="cascade.html#value-def-inherit" class="noxref"><span class="value-inst-inherit">inherit</span></a>
<tr valign=baseline><td><em>Initial:</em>&nbsp;&nbsp;<td>none
<tr valign=baseline><td><em>Applies to:</em>&nbsp;&nbsp;<td>所有元素
<tr valign=baseline><td><em>Inherited:</em>&nbsp;&nbsp;<td>no
<tr valign=baseline><td><em>Percentages:</em>&nbsp;&nbsp;<td>N/A
<tr valign=baseline><td><em>Media:</em>&nbsp;&nbsp;<td><a href="media.html#all-media-group" class="noxref">all</a>
<tr valign=baseline><td><em>Computed&nbsp;value:</em>&nbsp;&nbsp;<td>与指定值相同
</table>
</dl>
</div>


<p><a href="generate.html#propdef-counter-increment" class="noxref"><span class="propinst-counter-increment">'counter-increment'</span></a>属性接受一个或者多个计数器名（标识符），每个后面都可以跟一个可选的整数。这个整数表示每次出现该元素时计数器递增几。默认增量是1，可以接受0和负数

<p><a href="generate.html#propdef-counter-reset" class="noxref"><span class="propinst-counter-reset">'counter-reset'</span></a>属性也含有一列一个或者多个计数器，每个后面可以跟一个可选的整数。该整数给出了该元素每次出现时计数器的设定值，默认为0

<p>关键字'none'，'inherit'和'initial'不能用作计数器名。值为'none'表示不需要重置或者递增计数器。'Inherit'表示它（'Inherit'）的一般含义（见<a href="cascade.html#value-def-inherit">6.2.1</a>）。'Initial'是为将来用法保留的

<div class="example"><P style="display:none">示例：</P>
<p>本例展示了一种把章节编号为"Chapter 1"，"1.1"，"1.2"等等的方式：

<pre>
BODY {
    counter-reset: chapter;      /* Create a chapter counter scope */
}
H1:before {
    content: "Chapter " counter(chapter) ". ";
    counter-increment: chapter;  /* Add 1 to chapter */
}
H1 {
    counter-reset: section;      /* Set section to 0 */
}
H2:before {
    content: counter(chapter) "." counter(section) " ";
    counter-increment: section;
}
</pre>
</div>

<p>如果一个元素递增/重置一个计数器并使用了它（在其:before或:after伪元素的<a href="generate.html#propdef-content" class="noxref"><span class="propinst-content">'content'</span></a>属性中），计数器是在递增/重置<em>之后</em>才使用的

<p>如果一个元素重置并递增了一个计数器，计数器会先重置再递增

<p>如果给同一个计数器指定了多次<a href="generate.html#propdef-counter-reset" class="noxref"><span class="propinst-counter-reset">'counter-reset'</span></a>和<a href="generate.html#propdef-counter-increment" class="noxref"><span class="propinst-counter-increment">'counter-increment'</span></a>属性的值，计数器的每次重置/递增会按指定的顺序来处理

<div class="example"><P style="display:none">示例：</P>
<p>下例会把'section'计数器重置为0：

<pre>
H1 { counter-reset: section 2 section }
</pre>

<p>下例会把'chapter'计数器递增到3：

<pre>
H1 { counter-increment: chapter chapter 2 }
</pre>
</div>




<P><a href="generate.html#propdef-counter-reset" class="noxref"><span class="propinst-counter-reset">'counter-reset'</span></a>属性遵循层叠规则，因此，由于层叠，下列样式表：</p>

<pre class="example">
H1 { counter-reset: section -1 }
H1 { counter-reset: imagenum 99 }
</pre>

<p>只会重置'imagenum'。要同时重置两个计数器的话，它们必须一起指定：</p>

<pre class="example">
H1 { counter-reset: section -1 imagenum 99 }
</pre>

<h3>12.4.1 <a name="scope">嵌套计数器与范围</a></h3>

<p>计数器是“自嵌套的（self-nesting）”，如果重置一个位于后代元素或者伪元素中的计数器，会自动创建一个新的计数器实例。这对HTML中的列表之类的场景来说很重要，元素自身可以嵌套任意深度，这将无法为每一层定义唯一命名的计数器

<div class="example"><P style="display:none">示例：</P>
<p>因此，如下（样式表）就可以给嵌套列表项编号。结果与给LI元素设置'display:list-item'和'list-style: inside'非常相似：

<pre>
OL { counter-reset: item }
LI { display: block }
LI:before { content: counter(item) ". "; counter-increment: item }
</pre>
</div>

<p>一个计数器的<a name="x29"><span class="index-def" title="scope"><dfn>范围（scope）</dfn></span></a>从文档中第一个具有该计数器的<a href="generate.html#propdef-counter-reset" class="noxref"><span class="propinst-counter-reset">'counter-reset'</span></a>的元素开始，包括该元素的后代和它后面跟着的兄弟及其后代（includes the element's descendants and its following siblings with their descendants），但不包括通过该元素的后续兄弟的'counter-reset'或者后续相同元素的'counter-reset'创建的同名计数器范围内的任何元素

<p>如果一个元素或者伪元素上的<a href="generate.html#propdef-counter-increment" class="noxref"><span class="propinst-counter-increment">'counter-increment'</span></a>或者<a href="generate.html#propdef-content" class="noxref"><span class="propinst-content">'content'</span></a>引用了一个不处于任何<a href="generate.html#propdef-counter-reset" class="noxref"><span class="propinst-counter-reset">'counter-reset'</span></a>范围的计数器，实现应该表现得就像已经通过该元素或者伪元素上的一个<a href="generate.html#propdef-counter-reset" class="noxref"><span class="propinst-counter-reset">'counter-reset'</span></a>把该计数器重置为0了一样

<p>上例中，一个OL将会创建一个计数器，并且OL的所有子级将引用该计数器

<div class="html-example"> <p>如果我们用item[n]表示"item"计数器的第n个实例，用"{"和"}"表示一个范围的开始和结束，那么下列HTML片段将使用指定的计数器（我们假设样式表是上例中给出的那个）

<pre>
&lt;OL>                    &lt;!-- {item[0]=0        -->
  &lt;LI>item&lt;/LI>         &lt;!--  item[0]++ (=1)   -->
  &lt;LI>item              &lt;!--  item[0]++ (=2)   -->
    &lt;OL>                &lt;!--  {item[1]=0       -->
      &lt;LI>item&lt;/LI>     &lt;!--   item[1]++ (=1)  -->
      &lt;LI>item&lt;/LI>     &lt;!--   item[1]++ (=2)  -->
      &lt;LI>item          &lt;!--   item[1]++ (=3)  -->
        &lt;OL>            &lt;!--   {item[2]=0      -->
          &lt;LI>item&lt;/LI> &lt;!--    item[2]++ (=1) -->
        &lt;/OL>           &lt;!--                   -->
        &lt;OL>            &lt;!--   }{item[2]=0     -->
          &lt;LI>item&lt;/LI> &lt;!--    item[2]++ (=1) -->
        &lt;/OL>           &lt;!--                   -->
      &lt;/LI>             &lt;!--   }               -->
      &lt;LI>item&lt;/LI>     &lt;!--   item[1]++ (=4)  -->
    &lt;/OL>               &lt;!--                   -->
  &lt;/LI>                 &lt;!--  }                -->
  &lt;LI>item&lt;/LI>         &lt;!--  item[0]++ (=3)   -->
  &lt;LI>item&lt;/LI>         &lt;!--  item[0]++ (=4)   -->
&lt;/OL>                   &lt;!--                   -->
&lt;OL>                    &lt;!-- }{item[0]=0       -->
  &lt;LI>item&lt;/LI>         &lt;!--  item[0]++ (=1)   -->
  &lt;LI>item&lt;/LI>         &lt;!--  item[0]++ (=2)   -->
&lt;/OL>                   &lt;!--                   -->
</pre>
</div>

<div class="example"><P style="display:none">示例：</P>
<p>另一个示例，下面展示了当计数器用在非嵌套元素时，范围的作用方式。展示了上面给出的用来为章节编号的样式表怎样应用于给出的标记

<pre>
                     &lt;!--"chapter" counter|"section" counter -->
&lt;body>               &lt;!-- {chapter=0      |                  -->
  &lt;h1>About CSS&lt;/h1> &lt;!--  chapter++ (=1) | {section=0       -->
  &lt;h2>CSS 2&lt;/h2>     &lt;!--                 |  section++ (=1)  -->
  &lt;h2>CSS 2.1&lt;/h2>   &lt;!--                 |  section++ (=2)  -->
  &lt;h1>Style&lt;/h1>     &lt;!--  chapter++ (=2) |}{ section=0      -->
&lt;/body>              &lt;!--                 | }                -->
</pre>

</div>

<p>'counters()'函数生成一个由范围内所有同名计数器组成的字符串，用一个给定的字符串分隔

<div class="example"><P style="display:none">示例：</P><P>
<P>下列样式表会把嵌套的列表项编号为"1"，"1.1"，"1.1.1"等等

<PRE>
OL { counter-reset: item }
LI { display: block }
LI:before { content: counters(item, ".") " "; counter-increment: item }
</PRE>
</div>

<h3>12.4.2 <a name="counter-styles">计数器样式</a></h3>

<p>默认情况下，计数器会被格式化为十进制数，但<a href="generate.html#propdef-list-style-type" class="noxref"><span class="propinst-list-style-type">'list-style-type'</span></a>属性的所有可用样式也可以用于计数器，表示方式为：</P>

<pre>
counter(<var>name</var>)
</pre>
<p>对于默认样式表，或者：</p>

<pre>
counter(<var>name</var>, &lt;<a href="generate.html#propdef-list-style-type" class="noxref"><span class="propinst-list-style-type">'list-style-type'</span></a>&gt;)
</pre>

<p>所有样式都是合法的，包括'disc'，'circle'，'square'和'none'

<div class="example"><P style="display:none">示例：</P><P>

<pre>
H1:before        { content: counter(chno, upper-latin) ". " }
H2:before        { content: counter(section, upper-roman) " - " }
BLOCKQUOTE:after { content: " [" counter(bq, lower-greek) "]" }
DIV.note:before  { content: counter(notecntr, disc) " " }
P:before         { content: counter(p, none) }
</pre>
</div>


<h3>12.4.3 <a name="undisplayed-counters">'display: none'的元素中的计数器</a></h3>

<p>一个不显示的（<a href="visuren.html#propdef-display" class="noxref"><span
class="propinst-display">'display'</span></a>设置为'none'）元素不会让计数器递增或者重置

<div class="example"><P style="display:none">示例：</P>
<p>例如，用下列样式表，有"secret"类的H2不会让'count2'递增

<pre>
H2.secret {counter-increment: count2; display: none}
</pre>
</div>

<p>无法生成的伪元素也不会让计数器递增或者重置

<div class="example"><P style="display:none">示例：</P>
<p>例如，如下（样式表）不会让'heading'递增：

<pre>
h1::before {
    content: normal;
    counter-increment: heading;
}
</pre>
</div>

<p>然而，<a href="visufx.html#propdef-visibility" class="noxref"><span class="propinst-visibility">'visibility'</span></a>被设置为'hidden'的元素，<em>会</em>让计数器递增



<h2>12.5 <a name="lists">列表</a></h2>

<P>CSS 2.1提供了列表的基础可视化格式。一个具有'display: list-item'的元素会为该元素的内容生成一个<a href="visuren.html#principal-box">主块盒（principal block box）</a>，并且依赖'list-style-type'和'list-style-image'的值，也可能把一个标记盒（marker box）作为一个可视化指示，表示该元素是一个列表项

<P><a name="x30"><span class="index-def" title="list properties"><dfn>list属性</dfn></span></a>描述了列表的基础可视化格式：它们允许样式表指定标记类型（图片，字形或者数字），及标记相对主盒的位置（在它内部或者外部，在内容之前）。它们不允许编写者为列表标记指定确切的样式（颜色，字体，对齐方式等等）或者调整它相对于主盒的位置，这些都可以来自主盒

<P><a href="colors.html#background-properties">background属性</a>只适用于主盒，“外部的”标记盒是透明的
 

<h3>12.5.1 <a name="list-style">列表：</a><a href="generate.html#propdef-list-style-type" class="noxref"><span class="propinst-list-style-type">'list-style-type'</span></a>，<a href="generate.html#propdef-list-style-image" class="noxref"><span class="propinst-list-style-image">'list-style-image'</span></a>，<a href="generate.html#propdef-list-style-position" class="noxref"><span class="propinst-list-style-position">'list-style-position'</span></a>和<a href="generate.html#propdef-list-style" class="noxref"><span class="propinst-list-style">'list-style'</span></a>属性</h3>


<div class="propdef">
<dl><dt>
<span class="index-def" title="'list-style-type'"><a name="propdef-list-style-type" class="propdef-title"><strong>'list-style-type'</strong></a></span>
<dd>
<table class="propinfo" cellspacing=0 cellpadding=0>
<tr valign=baseline><td><em>Value:</em>&nbsp;&nbsp;<td>disc | circle | square | decimal | decimal-leading-zero | 
 lower-roman | upper-roman | lower-greek |
 lower-latin | upper-latin | armenian | georgian |
 lower-alpha | upper-alpha |
 none | <a href="cascade.html#value-def-inherit" class="noxref"><span class="value-inst-inherit">inherit</span></a>
<tr valign=baseline><td><em>Initial:</em>&nbsp;&nbsp;<td>disc
<tr valign=baseline><td><em>Applies to:</em>&nbsp;&nbsp;<td>具有'display: list-item'的元素
<tr valign=baseline><td><em>Inherited:</em>&nbsp;&nbsp;<td>yes
<tr valign=baseline><td><em>Percentages:</em>&nbsp;&nbsp;<td>N/A
<tr valign=baseline><td><em>Media:</em>&nbsp;&nbsp;<td><a href="media.html#visual-media-group" class="noxref">visual</a>
<tr valign=baseline><td><em>Computed&nbsp;value:</em>&nbsp;&nbsp;<td>与指定值相同
</table>
</dl>
</div>


<P>该属性指定了列表项标记的外观。如果<a href="generate.html#propdef-list-style-image" class="noxref"><span class="propinst-list-style-image">'list-style-image'</span></a>置为'none'或者如果URI指向的图片无法显示的话，'none'值指定了无标记，否则有三种标记类型：字形，数字系统（numbering systems）和字母系统（alphabetic systems）

<P>字形用<strong><span class="index-def" title="disc"><a class="value-def" name="value-def-disc">disc</a></span></strong>，<strong><span class="index-def" title="circle"><a class="value-def" name="value-def-circle">circle</a></span></strong>和<strong><span class="index-def" title="square"><a class="value-def" name="value-def-square">square</a></span></strong>来指定。其确切的渲染取决于用户代理

<P>数字系统通过下列（值）来指定：</P>

<dl>

<dt><span class="index-def" title="decimal"><a class="value-def" name="value-def-decimal"><strong>decimal</strong></a></span><dd>十进制数，从1开始

<dt><strong><span class="index-def" title="decimal-leading-zero"><a class="value-def" name="value-def-decimal-leading-zero">decimal-leading-zero</a></span></strong>
<dd>填充了前导0的十进制数（例如，01，02，03，...，98，99）



<dt><strong><span class="index-def" title="lower-roman"><a class="value-def" name="value-def-lower-roman">lower-roman</a></span></strong>
<dd>小写罗马数字（i，ii，iii，iv，v等等）

<dt><strong><span class="index-def" title="upper-roman"><a class="value-def" name="value-def-upper-roman">upper-roman</a></span></strong>
<dd>大写罗马数字（I，II，III，IV，V等等）

<dt><strong><span class="index-def" title="georgian"><a class="value-def" name="value-def-georgian">georgian</a></span></strong>
<dd>传统的格鲁吉亚（Georgian）编号（an，ban，gan，...，he，tan，in，in-an，...）
<dt><strong><span class="index-def" title="armenian"><a class="value-def" name="value-def-armenian">armenian</a></span></strong>
<dd>传统的大写亚美尼亚（Armenian）编号
</dl>


<P>字母系统通过下列（值）来指定：</P>

<dl>
<dt><strong><span class="index-def" title="lower-latin"><a class="value-def" name="value-def-lower-latin">lower-latin</a></span></strong>或者<strong>lower-alpha</strong>
<dd>小写ascii字母（a，b，c，... z）
<dt><strong><span class="index-def" title="upper-latin"><a class="value-def" name="value-def-upper-latin">upper-latin</a></span></strong>或者<strong>upper-alpha</strong>
<dd>大写ascii字母（A，B，C，... Z）
<dt><strong><span class="index-def" title="lower-greek"><a class="value-def" name="value-def-lower-greek">lower-greek</a></span></strong>
<dd>小写古典希腊alpha，beta，gamma，... （&#945;，&#946;，&#947;，...）
</dl>

<P>本规范没有定义字母系统怎样字母表结束处怎样处理（wrap），例如，在26个列表项之后，'lower-latin'的渲染是未定义的。因此，对于长列表，我们推荐编写者指定实数

<p>CSS&nbsp;2.1没有定义列表编号怎样重置和递增。预期在CSS List Module <a href="refs.html#ref-CSS3LIST" rel="biblioentry" class="noxref"><span class="informref">[CSS3LIST]</span></a>定义它

<div class="html-example"><P>
例如，下列HTML片段：

<PRE>
&lt;!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01//EN"&gt;
&lt;HTML&gt;
   &lt;HEAD&gt;
     &lt;TITLE&gt;Lowercase latin numbering&lt;/TITLE&gt;
     &lt;STYLE type="text/css"&gt;
          ol { list-style-type: lower-roman }   
     &lt;/STYLE&gt;
  &lt;/HEAD&gt;
  &lt;BODY&gt;
    &lt;OL&gt;
      &lt;LI&gt; This is the first item.
      &lt;LI&gt; This is the second item.
      &lt;LI&gt; This is the third item.
    &lt;/OL&gt;
  &lt;/BODY&gt;
&lt;/HTML&gt;
</PRE>

<P>产生的结果类似于：

<PRE>
  i This is the first item.
 ii This is the second item.
iii This is the third item.
</PRE>

<P>列表标记对齐方式（这里是右对齐）取决于用户代理

</div>


<div class="propdef">
<dl><dt>
<span class="index-def" title="'list-style-image'"><a name="propdef-list-style-image" class="propdef-title"><strong>'list-style-image'</strong></a></span>
<dd>
<table class="propinfo" cellspacing=0 cellpadding=0>
<tr valign=baseline><td><em>Value:</em>&nbsp;&nbsp;<td><a href="syndata.html#value-def-uri" class="noxref"><span class="value-inst-uri">&lt;uri&gt;</span></a> | none | <a href="cascade.html#value-def-inherit" class="noxref"><span class="value-inst-inherit">inherit</span></a>
<tr valign=baseline><td><em>Initial:</em>&nbsp;&nbsp;<td>none
<tr valign=baseline><td><em>Applies to:</em>&nbsp;&nbsp;<td>具有'display: list-item'的元素
<tr valign=baseline><td><em>Inherited:</em>&nbsp;&nbsp;<td>yes
<tr valign=baseline><td><em>Percentages:</em>&nbsp;&nbsp;<td>N/A
<tr valign=baseline><td><em>Media:</em>&nbsp;&nbsp;<td><a href="media.html#visual-media-group" class="noxref">visual</a>
<tr valign=baseline><td><em>Computed&nbsp;value:</em>&nbsp;&nbsp;<td>绝对URI或者'none'
</table>
</dl>
</div>


<P>该属性设置了将用作列表项标记的图片。当图片可用时，它将替换用<a href="generate.html#propdef-list-style-type" class="noxref"><span class="propinst-list-style-type">'list-style-type'</span></a>设置的标记

<p>图片的尺寸根据下列规则计算：
<ol>
<li>如果该图片具有一个内在宽度和高度，宽度和高度的应用值就是内在宽度和高度

<li>否则，如果该图片具有一个内在比例和一个内在宽度或者内在高度，宽度/高度的应用值与提供的内在宽度/高度相同，缺失的尺寸的应用值根据已提供的尺寸和比例来计算

<li>否则，如果图片具有一个内在比例，则宽度的应用值为1em，高度的应用值根据这个宽度和内在比例计算。如果这会让高度大于1em，那么高度的应用值就设置为1em，宽度的应用值根据这个高度和内在比例来计算

<li>否则，该图片宽度的应用值为其内在宽度，如果有的话，或者否则就是1em。图片高度的应用值为其内在高度，如果有的话，或者否则就是1em
</ol>

<div class="example"><P style="display:none">示例：</P><P>
下例把每个列表项的开始处的标记设置为图片"ellipse.png"


<PRE>
ul { list-style-image: url("http://png.com/ellipse.png") }
</PRE>
</div>

<div class="propdef">
<dl><dt>
<span class="index-def" title="'list-style-position'"><a name="propdef-list-style-position" class="propdef-title"><strong>'list-style-position'</strong></a></span>
<dd>
<table class="propinfo" cellspacing=0 cellpadding=0>
<tr valign=baseline><td><em>Value:</em>&nbsp;&nbsp;<td>inside | outside | <a href="cascade.html#value-def-inherit" class="noxref"><span class="value-inst-inherit">inherit</span></a>
<tr valign=baseline><td><em>Initial:</em>&nbsp;&nbsp;<td>outside
<tr valign=baseline><td><em>Applies to:</em>&nbsp;&nbsp;<td>具有'display: list-item'的元素
<tr valign=baseline><td><em>Inherited:</em>&nbsp;&nbsp;<td>yes
<tr valign=baseline><td><em>Percentages:</em>&nbsp;&nbsp;<td>N/A
<tr valign=baseline><td><em>Media:</em>&nbsp;&nbsp;<td><a href="media.html#visual-media-group" class="noxref">visual</a>
<tr valign=baseline><td><em>Computed&nbsp;value:</em>&nbsp;&nbsp;<td>与指定值相同
</table>
</dl>
</div>


<P>该属性指定了标记盒（marker box）相对于主块盒的位置（principal block box）。值含义如下：</p>

<dl>
<dt><strong>outside</strong>

<dd>标记盒位于主块盒外部。列表项标记的位置与浮动（盒）相邻的情况在CSS&nbsp;2.1中是未定义的。CSS&nbsp;2.1没有指定标记盒的精确位置或者它在绘制顺序中的位置，但对于那些'direction'属性为'ltr'的列表项，标记盒必须位于内容的右边。标记盒相对于主块盒的边框是固定的，不会随主块盒的内容滚动。CSS&nbsp;2.1中，UA可能会隐藏标记，如果该元素的<a href="visufx.html#propdef-overflow" class="noxref"><span class=propinst-overflow>'overflow'</span></a>不为'visible'的话（这在将来可能会变更）。标记盒的尺寸或者内容可能会影响主块盒的高度和/或其第一个行盒的高度，某些情况下，可能会创建一个新的行盒。<span class=note><strong>注意：</strong>这种相互影响可能会在将来的CSS版本中进行更精确的定义</span>

<dt><strong>inside</strong>

<dd>标记盒位于主块盒的第一个行盒，在该元素的内容和所有:before伪元素之前。CSS&nbsp;2.1没有指定标记盒的精确位置

</dl>

<div class="html-example"><P>
例如：

<PRE>
&lt;HTML&gt;
  &lt;HEAD&gt;
    &lt;TITLE&gt;Comparison of inside/outside position&lt;/TITLE&gt;
    &lt;STYLE type="text/css"&gt;
      ul         { list-style: outside }
      ul.compact { list-style: inside }
    &lt;/STYLE&gt;
  &lt;/HEAD&gt;
  &lt;BODY&gt;
    &lt;UL&gt;
      &lt;LI&gt;first list item comes first
      &lt;LI&gt;second list item comes second
    &lt;/UL&gt;

    &lt;UL class="compact"&gt;
      &lt;LI&gt;first list item comes first
      &lt;LI&gt;second list item comes second
    &lt;/UL&gt;
  &lt;/BODY&gt;
&lt;/HTML&gt;
</PRE>

<P>上例可能会被格式化为：</P>

<div class="figure">
<P><img src="./images/list-inout.png" alt="Difference between inside
and outside list style position"><SPAN class="dlink">&nbsp;&nbsp;&nbsp;<A name="img-list-inout" href="images/longdesc/list-inout-desc.html" title="Long description for example showing inside vs. outside
list marker">[D]</A></SPAN></p>
</div>

<P>在从右向左的文本中，标记将位于该盒的右边
</div>

<div class="propdef">
<dl><dt>
<span class="index-def" title="'list-style'"><a name="propdef-list-style" class="propdef-title"><strong>'list-style'</strong></a></span>
<dd>
<table class="propinfo" cellspacing=0 cellpadding=0>
<tr valign=baseline><td><em>Value:</em>&nbsp;&nbsp;<td>[ <a href="generate.html#propdef-list-style-type" class="noxref"><span class="propinst-list-style-type">&lt;'list-style-type'&gt;</span></a> || <a href="generate.html#propdef-list-style-position" class="noxref"><span class="propinst-list-style-position">&lt;'list-style-position'&gt;</span></a> || <a href="generate.html#propdef-list-style-image" class="noxref"><span class="propinst-list-style-image">&lt;'list-style-image'&gt;</span></a> ] | <a href="cascade.html#value-def-inherit" class="noxref"><span class="value-inst-inherit">inherit</span></a>
<tr valign=baseline><td><em>Initial:</em>&nbsp;&nbsp;<td>见单独的各个属性
<tr valign=baseline><td><em>Applies to:</em>&nbsp;&nbsp;<td>具有'display: list-item'的元素
<tr valign=baseline><td><em>Inherited:</em>&nbsp;&nbsp;<td>yes
<tr valign=baseline><td><em>Percentages:</em>&nbsp;&nbsp;<td>N/A
<tr valign=baseline><td><em>Media:</em>&nbsp;&nbsp;<td><a href="media.html#visual-media-group" class="noxref">visual</a>
<tr valign=baseline><td><em>Computed&nbsp;value:</em>&nbsp;&nbsp;<td>见单独的各个属性
</table>
</dl>
</div>


<P><a href="generate.html#propdef-list-style" class="noxref"><span class="propinst-list-style">'list-style'</span></a>属性是在样式表中一次性设置<a href="generate.html#propdef-list-style-type" class="noxref"><span class="propinst-list-style-type">'list-style-type'</span></a>，<a href="generate.html#propdef-list-style-image" class="noxref"><span class="propinst-list-style-image">'list-style-image'</span></a>和<a href="generate.html#propdef-list-style-position" class="noxref"><span class="propinst-list-style-position">'list-style-position'</span></a>三个属性的简写表示法

<div class="example"><P style="display:none">示例：</P><P>

<PRE>
ul { list-style: upper-roman inside }  /* Any "ul" element */
ul > li > ul { list-style: circle outside } /* Any "ul" child 
                                             of an "li" child 
                                             of a "ul" element */
</PRE>
</div>

<P>尽管编写者可能直接给列表项元素（例如，HTML中的"li"）指定<a href="generate.html#propdef-list-style" class="noxref"><span class="propinst-list-style">'list-style'</span></a>信息，但这样做要特别小心。下列规则看起来很相似，但第一条声明了一个<a href="./selector.html#descendant-selectors">后代选择器</a>，而第二条声明了一个（更特殊的）<a href="./selector.html#child-selectors">子选择器</a>

<PRE class="example">
ol.alpha li   { list-style: lower-alpha } /* Any "li" descendant of an "ol" */ 
ol.alpha > li { list-style: lower-alpha } /* Any "li" child of an "ol" */
</PRE>

<P>那些只用<a href="selector.html#descendant-selectors">后代选择器</a>的编写者可能无法得到他们预期的结果。考虑下列规则：

<PRE class="html-example">
&lt;HTML&gt;
  &lt;HEAD&gt;
    &lt;TITLE&gt;WARNING: Unexpected results due to cascade&lt;/TITLE&gt;
    &lt;STYLE type="text/css"&gt;
      ol.alpha li  { list-style: lower-alpha }
      ul li        { list-style: disc }
    &lt;/STYLE&gt;
  &lt;/HEAD&gt;
  &lt;BODY&gt;
    &lt;OL class="alpha"&gt;
      &lt;LI&gt;level 1
      &lt;UL&gt;
         &lt;LI&gt;level 2
      &lt;/UL&gt;
    &lt;/OL&gt;
  &lt;/BODY&gt;
&lt;/HTML&gt;
</PRE>

<P>想要的渲染效果是让1级列表项带有'lower-alpha'标签，2级列表项带有'disc'标签。然而，<a href="./cascade.html#cascading-order">层叠顺序</a>会让第一条样式规则（包括特殊类信息的）掩盖掉第二条。下列规则通过换用<a href="./selector.html#child-selectors">子选择器</a>解决了这个问题：

<PRE class="example">
ol.alpha > li  { list-style: lower-alpha }
ul li   { list-style: disc }
</PRE>

<P>另一个方案是只对列表类型的元素指定<a href="generate.html#propdef-list-style" class="noxref"><span class="propinst-list-style">'list-style'</span></a>信息：

<PRE class="example">
ol.alpha  { list-style: lower-alpha }
ul        { list-style: disc }
</PRE>

<P>继承机制会让<a href="generate.html#propdef-list-style" class="noxref"><span class="propinst-list-style">'list-style'</span></a>的值从OL和UL元素转移到LI元素。这是指定列表样式信息的推荐方式

<div class="example"><P style="display:none">示例：</P>
<P>一个URI值可以与其它值结合起来，如：

<PRE>
ul { list-style: url("http://png.com/ellipse.png") disc }
</PRE>
<P>上例中，当图片不可用时，将使用'disc'
</div>

<P><a href="generate.html#propdef-list-style" class="noxref"><span class="propinst-list-style">'list-style'</span></a>属性中的'none'值会把<a href="generate.html#propdef-list-style-type" class="noxref"><span class="propinst-list-style-type">'list-style-type'</span></a>和<a href="generate.html#propdef-list-style-image" class="noxref"><span class="propinst-list-style-image">'list-style-image'</span></a>中不为'none'的设置为'none'。然而，如果都指定了，该声明就属于错误情况（从而忽略它）（A value of 'none' within the 'list-style' property sets whichever of 'list-style-type' and 'list-style-image' are not otherwise specified to 'none'. However, if both are otherwise specified, the declaration is in error (and thus ignored).）

<div class="example"><P style="display:none">示例：</P>
<P>例如，值为'none'的<a href="generate.html#propdef-list-style" class="noxref"><span class="propinst-list-style">'list-style'</span></a>属性会把<a href="generate.html#propdef-list-style-type" class="noxref"><span class="propinst-list-style-type">'list-style-type'</span></a>和<a href="generate.html#propdef-list-style-image" class="noxref"><span class="propinst-list-style-image">'list-style-image'</span></a>设置为'none'：

<PRE>
ul { list-style: none }
</PRE>

<P>结果是不会显示列表项标记

</div>

<hr class="navbar">

<div class="navbar">
<p><a href="visufx.html">上一章</a> &nbsp;
<a href="page.html">下一章</a> &nbsp;
<a href="cover.html#minitoc">内容</a> &nbsp;
<a href="propidx.html">属性</a> &nbsp;
<a href="indexlist.html">索引</a> &nbsp;
</div>
</body>
</html>

